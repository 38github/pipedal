
/*
 * This file was automatically generated by sdbus-c++-xml2cpp; DO NOT EDIT!
 */

#ifndef __sdbuscpp___home_rerdavies_src_pipedal_src_dbus_bluez_adaptor_h__adaptor__H__
#define __sdbuscpp___home_rerdavies_src_pipedal_src_dbus_bluez_adaptor_h__adaptor__H__

#include <sdbus-c++/sdbus-c++.h>
#include <string>
#include <tuple>

namespace org {
namespace bluez {

class GattService1_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.bluez.GattService1";

protected:
    GattService1_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerProperty("UUID").onInterface(INTERFACE_NAME).withGetter([this](){ return this->UUID(); });
        object_.registerProperty("Primary").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Primary(); });
        object_.registerProperty("Characteristics").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Characteristics(); });
    }

    ~GattService1_adaptor() = default;

private:
    virtual std::string UUID() = 0;
    virtual bool Primary() = 0;
    virtual std::vector<sdbus::ObjectPath> Characteristics() = 0;

private:
    sdbus::IObject& object_;
};

}} // namespaces

namespace org {
namespace bluez {

class GattCharacteristic1_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.bluez.GattCharacteristic1";

protected:
    GattCharacteristic1_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("WriteValue").onInterface(INTERFACE_NAME).withInputParamNames("value").implementedAs([this](const std::vector<uint8_t>& value){ return this->WriteValue(value); });
        object_.registerMethod("StartNotify").onInterface(INTERFACE_NAME).implementedAs([this](){ return this->StartNotify(); });
        object_.registerMethod("StopNotify").onInterface(INTERFACE_NAME).implementedAs([this](){ return this->StopNotify(); });
        object_.registerProperty("UUID").onInterface(INTERFACE_NAME).withGetter([this](){ return this->UUID(); });
        object_.registerProperty("Service").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Service(); });
        object_.registerProperty("Value").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Value(); });
        object_.registerProperty("Notifying").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Notifying(); });
        object_.registerProperty("Flags").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Flags(); });
        object_.registerProperty("Descriptors").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Descriptors(); });
    }

    ~GattCharacteristic1_adaptor() = default;

private:
    virtual void WriteValue(const std::vector<uint8_t>& value) = 0;
    virtual void StartNotify() = 0;
    virtual void StopNotify() = 0;

private:
    virtual std::string UUID() = 0;
    virtual sdbus::ObjectPath Service() = 0;
    virtual std::vector<uint8_t> Value() = 0;
    virtual bool Notifying() = 0;
    virtual std::vector<std::string> Flags() = 0;
    virtual std::vector<sdbus::ObjectPath> Descriptors() = 0;

private:
    sdbus::IObject& object_;
};

}} // namespaces

namespace org {
namespace bluez {

class GattDescriptor1_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.bluez.GattDescriptor1";

protected:
    GattDescriptor1_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("ReadValue").onInterface(INTERFACE_NAME).withOutputParamNames("value").implementedAs([this](){ return this->ReadValue(); });
        object_.registerProperty("UUID").onInterface(INTERFACE_NAME).withGetter([this](){ return this->UUID(); });
        object_.registerProperty("Characteristic").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Characteristic(); });
        object_.registerProperty("Value").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Value(); });
        object_.registerProperty("Flags").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Flags(); });
    }

    ~GattDescriptor1_adaptor() = default;

private:
    virtual std::vector<uint8_t> ReadValue() = 0;

private:
    virtual std::string UUID() = 0;
    virtual sdbus::ObjectPath Characteristic() = 0;
    virtual std::vector<uint8_t> Value() = 0;
    virtual std::vector<std::string> Flags() = 0;

private:
    sdbus::IObject& object_;
};

}} // namespaces

namespace org {
namespace bluez {

class LEAdvertisement1_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.bluez.LEAdvertisement1";

protected:
    LEAdvertisement1_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("Release").onInterface(INTERFACE_NAME).implementedAs([this](){ return this->Release(); }).withNoReply();
        object_.registerProperty("Type").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Type(); });
        object_.registerProperty("ServiceUUIDs").onInterface(INTERFACE_NAME).withGetter([this](){ return this->ServiceUUIDs(); });
        object_.registerProperty("ManufacturerData").onInterface(INTERFACE_NAME).withGetter([this](){ return this->ManufacturerData(); });
        object_.registerProperty("SolicitUUIDs").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SolicitUUIDs(); });
        object_.registerProperty("ServiceData").onInterface(INTERFACE_NAME).withGetter([this](){ return this->ServiceData(); });
        object_.registerProperty("IncludeTxPower").onInterface(INTERFACE_NAME).withGetter([this](){ return this->IncludeTxPower(); });
    }

    ~LEAdvertisement1_adaptor() = default;

private:
    virtual void Release() = 0;

private:
    virtual std::string Type() = 0;
    virtual std::vector<std::string> ServiceUUIDs() = 0;
    virtual std::map<std::string, sdbus::Variant> ManufacturerData() = 0;
    virtual std::vector<std::string> SolicitUUIDs() = 0;
    virtual std::map<std::string, sdbus::Variant> ServiceData() = 0;
    virtual bool IncludeTxPower() = 0;

private:
    sdbus::IObject& object_;
};

}} // namespaces

namespace org {
namespace freedesktop {
namespace DBus {

class Introspectable_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.DBus.Introspectable";

protected:
    Introspectable_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("Introspect").onInterface(INTERFACE_NAME).withOutputParamNames("xml").implementedAs([this](){ return this->Introspect(); });
    }

    ~Introspectable_adaptor() = default;

private:
    virtual std::string Introspect() = 0;

private:
    sdbus::IObject& object_;
};

}}} // namespaces

namespace org {
namespace bluez {

class Adapter1_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.bluez.Adapter1";

protected:
    Adapter1_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("StartDiscovery").onInterface(INTERFACE_NAME).implementedAs([this](){ return this->StartDiscovery(); });
        object_.registerMethod("SetDiscoveryFilter").onInterface(INTERFACE_NAME).withInputParamNames("properties").implementedAs([this](const std::map<std::string, sdbus::Variant>& properties){ return this->SetDiscoveryFilter(properties); });
        object_.registerMethod("StopDiscovery").onInterface(INTERFACE_NAME).implementedAs([this](){ return this->StopDiscovery(); });
        object_.registerMethod("RemoveDevice").onInterface(INTERFACE_NAME).withInputParamNames("device").implementedAs([this](const sdbus::ObjectPath& device){ return this->RemoveDevice(device); });
        object_.registerMethod("GetDiscoveryFilters").onInterface(INTERFACE_NAME).withOutputParamNames("filters").implementedAs([this](){ return this->GetDiscoveryFilters(); });
        object_.registerProperty("Address").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Address(); });
        object_.registerProperty("AddressType").onInterface(INTERFACE_NAME).withGetter([this](){ return this->AddressType(); });
        object_.registerProperty("Name").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Name(); });
        object_.registerProperty("Alias").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Alias(); }).withSetter([this](const std::string& value){ this->Alias(value); });
        object_.registerProperty("Class").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Class(); });
        object_.registerProperty("Powered").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Powered(); }).withSetter([this](const bool& value){ this->Powered(value); });
        object_.registerProperty("Discoverable").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Discoverable(); }).withSetter([this](const bool& value){ this->Discoverable(value); });
        object_.registerProperty("DiscoverableTimeout").onInterface(INTERFACE_NAME).withGetter([this](){ return this->DiscoverableTimeout(); }).withSetter([this](const uint32_t& value){ this->DiscoverableTimeout(value); });
        object_.registerProperty("Pairable").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Pairable(); }).withSetter([this](const bool& value){ this->Pairable(value); });
        object_.registerProperty("PairableTimeout").onInterface(INTERFACE_NAME).withGetter([this](){ return this->PairableTimeout(); }).withSetter([this](const uint32_t& value){ this->PairableTimeout(value); });
        object_.registerProperty("Discovering").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Discovering(); });
        object_.registerProperty("UUIDs").onInterface(INTERFACE_NAME).withGetter([this](){ return this->UUIDs(); });
        object_.registerProperty("Modalias").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Modalias(); });
        object_.registerProperty("Roles").onInterface(INTERFACE_NAME).withGetter([this](){ return this->Roles(); });
    }

    ~Adapter1_adaptor() = default;

private:
    virtual void StartDiscovery() = 0;
    virtual void SetDiscoveryFilter(const std::map<std::string, sdbus::Variant>& properties) = 0;
    virtual void StopDiscovery() = 0;
    virtual void RemoveDevice(const sdbus::ObjectPath& device) = 0;
    virtual std::vector<std::string> GetDiscoveryFilters() = 0;

private:
    virtual std::string Address() = 0;
    virtual std::string AddressType() = 0;
    virtual std::string Name() = 0;
    virtual std::string Alias() = 0;
    virtual void Alias(const std::string& value) = 0;
    virtual uint32_t Class() = 0;
    virtual bool Powered() = 0;
    virtual void Powered(const bool& value) = 0;
    virtual bool Discoverable() = 0;
    virtual void Discoverable(const bool& value) = 0;
    virtual uint32_t DiscoverableTimeout() = 0;
    virtual void DiscoverableTimeout(const uint32_t& value) = 0;
    virtual bool Pairable() = 0;
    virtual void Pairable(const bool& value) = 0;
    virtual uint32_t PairableTimeout() = 0;
    virtual void PairableTimeout(const uint32_t& value) = 0;
    virtual bool Discovering() = 0;
    virtual std::vector<std::string> UUIDs() = 0;
    virtual std::string Modalias() = 0;
    virtual std::vector<std::string> Roles() = 0;

private:
    sdbus::IObject& object_;
};

}} // namespaces

namespace org {
namespace freedesktop {
namespace DBus {

class Properties_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.freedesktop.DBus.Properties";

protected:
    Properties_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("Get").onInterface(INTERFACE_NAME).withInputParamNames("interface", "name").withOutputParamNames("value").implementedAs([this](const std::string& interface, const std::string& name){ return this->Get(interface, name); });
        object_.registerMethod("Set").onInterface(INTERFACE_NAME).withInputParamNames("interface", "name", "value").implementedAs([this](const std::string& interface, const std::string& name, const sdbus::Variant& value){ return this->Set(interface, name, value); });
        object_.registerMethod("GetAll").onInterface(INTERFACE_NAME).withInputParamNames("interface").withOutputParamNames("properties").implementedAs([this](const std::string& interface){ return this->GetAll(interface); });
        object_.registerSignal("PropertiesChanged").onInterface(INTERFACE_NAME).withParameters<std::string, std::map<std::string, sdbus::Variant>, std::vector<std::string>>("interface", "changed_properties", "invalidated_properties");
    }

    ~Properties_adaptor() = default;

public:
    void emitPropertiesChanged(const std::string& interface, const std::map<std::string, sdbus::Variant>& changed_properties, const std::vector<std::string>& invalidated_properties)
    {
        object_.emitSignal("PropertiesChanged").onInterface(INTERFACE_NAME).withArguments(interface, changed_properties, invalidated_properties);
    }

private:
    virtual sdbus::Variant Get(const std::string& interface, const std::string& name) = 0;
    virtual void Set(const std::string& interface, const std::string& name, const sdbus::Variant& value) = 0;
    virtual std::map<std::string, sdbus::Variant> GetAll(const std::string& interface) = 0;

private:
    sdbus::IObject& object_;
};

}}} // namespaces

namespace org {
namespace bluez {

class GattManager1_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.bluez.GattManager1";

protected:
    GattManager1_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("RegisterApplication").onInterface(INTERFACE_NAME).withInputParamNames("application", "options").implementedAs([this](const sdbus::ObjectPath& application, const std::map<std::string, sdbus::Variant>& options){ return this->RegisterApplication(application, options); });
        object_.registerMethod("UnregisterApplication").onInterface(INTERFACE_NAME).withInputParamNames("application").implementedAs([this](const sdbus::ObjectPath& application){ return this->UnregisterApplication(application); });
    }

    ~GattManager1_adaptor() = default;

private:
    virtual void RegisterApplication(const sdbus::ObjectPath& application, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void UnregisterApplication(const sdbus::ObjectPath& application) = 0;

private:
    sdbus::IObject& object_;
};

}} // namespaces

namespace org {
namespace bluez {

class LEAdvertisingManager1_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.bluez.LEAdvertisingManager1";

protected:
    LEAdvertisingManager1_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("RegisterAdvertisement").onInterface(INTERFACE_NAME).withInputParamNames("advertisement", "options").implementedAs([this](const sdbus::ObjectPath& advertisement, const std::map<std::string, sdbus::Variant>& options){ return this->RegisterAdvertisement(advertisement, options); });
        object_.registerMethod("UnregisterAdvertisement").onInterface(INTERFACE_NAME).withInputParamNames("service").implementedAs([this](const sdbus::ObjectPath& service){ return this->UnregisterAdvertisement(service); });
        object_.registerProperty("ActiveInstances").onInterface(INTERFACE_NAME).withGetter([this](){ return this->ActiveInstances(); });
        object_.registerProperty("SupportedInstances").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SupportedInstances(); });
        object_.registerProperty("SupportedIncludes").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SupportedIncludes(); });
        object_.registerProperty("SupportedSecondaryChannels").onInterface(INTERFACE_NAME).withGetter([this](){ return this->SupportedSecondaryChannels(); });
    }

    ~LEAdvertisingManager1_adaptor() = default;

private:
    virtual void RegisterAdvertisement(const sdbus::ObjectPath& advertisement, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void UnregisterAdvertisement(const sdbus::ObjectPath& service) = 0;

private:
    virtual uint8_t ActiveInstances() = 0;
    virtual uint8_t SupportedInstances() = 0;
    virtual std::vector<std::string> SupportedIncludes() = 0;
    virtual std::vector<std::string> SupportedSecondaryChannels() = 0;

private:
    sdbus::IObject& object_;
};

}} // namespaces

namespace org {
namespace bluez {

class Media1_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.bluez.Media1";

protected:
    Media1_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("RegisterEndpoint").onInterface(INTERFACE_NAME).withInputParamNames("endpoint", "properties").implementedAs([this](const sdbus::ObjectPath& endpoint, const std::map<std::string, sdbus::Variant>& properties){ return this->RegisterEndpoint(endpoint, properties); });
        object_.registerMethod("UnregisterEndpoint").onInterface(INTERFACE_NAME).withInputParamNames("endpoint").implementedAs([this](const sdbus::ObjectPath& endpoint){ return this->UnregisterEndpoint(endpoint); });
        object_.registerMethod("RegisterPlayer").onInterface(INTERFACE_NAME).withInputParamNames("player", "properties").implementedAs([this](const sdbus::ObjectPath& player, const std::map<std::string, sdbus::Variant>& properties){ return this->RegisterPlayer(player, properties); });
        object_.registerMethod("UnregisterPlayer").onInterface(INTERFACE_NAME).withInputParamNames("player").implementedAs([this](const sdbus::ObjectPath& player){ return this->UnregisterPlayer(player); });
        object_.registerMethod("RegisterApplication").onInterface(INTERFACE_NAME).withInputParamNames("application", "options").implementedAs([this](const sdbus::ObjectPath& application, const std::map<std::string, sdbus::Variant>& options){ return this->RegisterApplication(application, options); });
        object_.registerMethod("UnregisterApplication").onInterface(INTERFACE_NAME).withInputParamNames("application").implementedAs([this](const sdbus::ObjectPath& application){ return this->UnregisterApplication(application); });
    }

    ~Media1_adaptor() = default;

private:
    virtual void RegisterEndpoint(const sdbus::ObjectPath& endpoint, const std::map<std::string, sdbus::Variant>& properties) = 0;
    virtual void UnregisterEndpoint(const sdbus::ObjectPath& endpoint) = 0;
    virtual void RegisterPlayer(const sdbus::ObjectPath& player, const std::map<std::string, sdbus::Variant>& properties) = 0;
    virtual void UnregisterPlayer(const sdbus::ObjectPath& player) = 0;
    virtual void RegisterApplication(const sdbus::ObjectPath& application, const std::map<std::string, sdbus::Variant>& options) = 0;
    virtual void UnregisterApplication(const sdbus::ObjectPath& application) = 0;

private:
    sdbus::IObject& object_;
};

}} // namespaces

namespace org {
namespace bluez {

class NetworkServer1_adaptor
{
public:
    static constexpr const char* INTERFACE_NAME = "org.bluez.NetworkServer1";

protected:
    NetworkServer1_adaptor(sdbus::IObject& object)
        : object_(object)
    {
        object_.registerMethod("Register").onInterface(INTERFACE_NAME).withInputParamNames("uuid", "bridge").implementedAs([this](const std::string& uuid, const std::string& bridge){ return this->Register(uuid, bridge); });
        object_.registerMethod("Unregister").onInterface(INTERFACE_NAME).withInputParamNames("uuid").implementedAs([this](const std::string& uuid){ return this->Unregister(uuid); });
    }

    ~NetworkServer1_adaptor() = default;

private:
    virtual void Register(const std::string& uuid, const std::string& bridge) = 0;
    virtual void Unregister(const std::string& uuid) = 0;

private:
    sdbus::IObject& object_;
};

}} // namespaces

#endif
